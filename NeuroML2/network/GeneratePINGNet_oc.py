#!/usr/bin/python
# -*- coding: utf-8 -*-
""" 
Creates a PC-BC network, producing gamma oscillation - generated by PING mechanism
The script is based on the NeuroML version of the model and aims to show easy reusability!
Authors: AndrÃ¡s Ecker, Padraig Gleeson, last update: 08.2017
"""

import sys
import warnings
# NeuroML specific libraries
import opencortex.core as oc
import opencortex.build as oc_build
import neuroml
from pyneuroml import pynml
# helper functions from other scripts
from GenerateHippocampalNet_oc import helper_getcolor
from analyse_PING import *


def add_pop(nml_doc, network, cell_type, pop_size, duration=None, rate=None):
    """adds population using opencortex function"""
    
    if cell_type not in ["ca3", "ec"]:  # "real" cells have template
        return oc.add_population_in_rectangular_region(network,
                                                       pop_id="pop_%s"%cell_type, cell_id="%scell"%cell_type,
                                                       size=pop_size,
                                                       x_min=0, y_min=0, z_min=0,
                                                       x_size=2000, y_size=2000, z_size=2000,
                                                       color=helper_getcolor(cell_type))
                                                   
    else:
        spike_gen = oc.add_spike_source_poisson(nml_doc, id="stim_%s"%cell_type,
                                                start="0ms", duration="%fms"%duration, rate="%fHz"%rate)  # duration and rate used only here
        
        return oc.add_population_in_rectangular_region(network,
                                                       pop_id="pop_%s"%cell_type, cell_id=spike_gen.id,
                                                       size=pop_size,
                                                       x_min=0, y_min=0, z_min=0,
                                                       x_size=2000, y_size=2000, z_size=2000,
                                                       color=helper_getcolor(cell_type))
                                                 
                                                  
def add_proj(network, prepop, postpop, ncons, post_seg_group, weight_mult=1):
    """adds targeted projection using opencortex function"""
    
    import re
    precell_type = re.split(r'\_', prepop.id)[1]
    postcell_type = re.split(r'\_', postpop.id)[1]
    
    if precell_type not in ["ca3", "ec"]:
        pre_seg_group = "soma_group"
    else:
        pre_seg_group = None  # will leave preSegmentId and preFractionAlong in the generated file (which is the way how 'artificial cells' connect to 'real cells')
    
    return oc.add_targeted_projection(network,
                                      prefix="proj",
                                      presynaptic_population=prepop,
                                      postsynaptic_population=postpop,
                                      targeting_mode="convergent",
                                      synapse_list=["syn_%s_to_%s"%(precell_type, postcell_type)],
                                      number_conns_per_cell=ncons,
                                      pre_segment_group=pre_seg_group,
                                      post_segment_group=post_seg_group,
                                      delays_dict={"syn_%s_to_%s"%(precell_type, postcell_type):3},
                                      weights_dict={"syn_%s_to_%s"%(precell_type, postcell_type):weight_mult})


def generate_PING_net(networkID, dPopsize, dNconns, dWeightMults, rate=5,
                      generate_LEMS=True, duration=100, dt=0.01):
    """generates PC-BC network using methods above"""
    
    if dt > 0.015:
        warnings.warn("\n***** dt bigger than 0.015 results continuous PV+BC spiking ! *****\n")
    
    nml_doc, network = oc.generate_network(networkID, network_seed=12345, temperature="34degC")
    
    # include necessary files
    nml_doc.includes.append(neuroml.IncludeType(href="../cells/poolosyn.cell.nml"))
    nml_doc.includes.append(neuroml.IncludeType(href="../cells/pvbasket.cell.nml"))
    # workaround to handle opencortex's way of including cell templates
    oc_build.cell_ids_vs_nml_docs["poolosyncell"] = pynml.read_neuroml2_file("../cells/poolosyn.cell.nml", include_includes=False)    
    oc_build.cell_ids_vs_nml_docs["pvbasketcell"] = pynml.read_neuroml2_file("../cells/pvbasket.cell.nml", include_includes=False)
    nml_doc.includes.append(neuroml.IncludeType(href="../synapses/exp2Synapses.synapse.nml"))
    
    # create populations
    pop_poolosyn = add_pop(nml_doc, network, "poolosyn", dPopsize["poolosyn"])
    pop_pvbasket = add_pop(nml_doc, network, "pvbasket", dPopsize["pvbasket"])
    pop_ca3 = add_pop(nml_doc, network, "ca3", dPopsize["stim"], duration=duration, rate=rate)  # int(0.75*dPopsize["poolosyn"])
    pop_ec = add_pop(nml_doc, network, "ec", dPopsize["stim"], duration=duration, rate=rate)
                                                       
    # add connections (synapses as in conndata_430.dat and syndata_120.dat)
    total_cons = 0
    proj_poolosyn_to_pvbasket = add_proj(network,
                                         prepop=pop_poolosyn, postpop=pop_pvbasket,
                                         ncons=dNconns["proj_poolosyn_to_pvbasket"],
                                         post_seg_group="apical_list_100_to_1000",
                                         weight_mult=dWeightMults["proj_poolosyn_to_pvbasket"])
    total_cons += len(proj_poolosyn_to_pvbasket[0].connection_wds)                                           
    proj_pvbasket_to_poolosyn = add_proj(network,
                                         prepop=pop_pvbasket, postpop=pop_poolosyn,
                                         ncons=dNconns["proj_pvbasket_to_poolosyn"],
                                         post_seg_group="soma_group",
                                         weight_mult=dWeightMults["proj_pvbasket_to_poolosyn"])
    total_cons += len(proj_pvbasket_to_poolosyn[0].connection_wds)                                           
    proj_pvbasket_to_pvbasket = add_proj(network,
                                         prepop=pop_pvbasket, postpop=pop_pvbasket,
                                         ncons=dNconns["proj_pvbasket_to_pvbasket"],
                                         post_seg_group="soma_group",
                                         weight_mult=dWeightMults["proj_pvbasket_to_pvbasket"])
    total_cons += len(proj_pvbasket_to_pvbasket[0].connection_wds)
    print("number of connections: %i (outer stimulation not included)"%total_cons)
    
    proj_ca3_to_poolosyn = add_proj(network,
                                    prepop=pop_ca3, postpop=pop_poolosyn,
                                    ncons=dNconns["proj_ca3_to_poolosyn"],
                                    post_seg_group="dendrite_list_50_to_200",
                                    weight_mult=dWeightMults["proj_ca3_to_poolosyn"])
    proj_ec_to_poolosyn = add_proj(network,
                                   prepop=pop_ec, postpop=pop_poolosyn,
                                   ncons=dNconns["proj_ec_to_poolosyn"],
                                   post_seg_group="dendrite_list_200_to_1000",
                                   weight_mult=dWeightMults["proj_ec_to_poolosyn"])
    proj_ca3_to_pvbasket = add_proj(network,
                                    prepop=pop_ca3, postpop=pop_pvbasket,
                                    ncons=dNconns["proj_ca3_to_pvbasket"],
                                    post_seg_group="dendrite_list_50_to_200",
                                    weight_mult=dWeightMults["proj_ca3_to_pvbasket"])                       
                                            
    # save to file
    nml_fName = "%s.net.nml"%network.id
    oc.save_network(nml_doc, nml_fName,
                    validate=True, format="xml", use_subfolder=False)
    
    if generate_LEMS:
    
        # create display for both population
        plots= {}
        max_traces = 5
        display_poolosyn = "Display_%s_v"%pop_poolosyn.id
        plots[display_poolosyn] = []
        display_pvbasket = "Display_%s_v"%pop_pvbasket.id
        plots[display_pvbasket] = []
        for i in range(0, max_traces):
            quantity_poolosyn = "%s/%i/%s/v"%(pop_poolosyn.id, i, pop_poolosyn.component)
            plots[display_poolosyn].append(quantity_poolosyn)
            quantity_pvbasket = "%s/%i/%s/v"%(pop_pvbasket.id, i, pop_pvbasket.component)
            plots[display_pvbasket].append(quantity_pvbasket)
        
        lems_fName = oc.generate_lems_simulation(nml_doc, network, nml_fName,
                                                 duration=duration, dt=dt,
                                                 gen_plots_for_all_v=False,
                                                 gen_plots_for_quantities=plots,
                                                 gen_saves_for_all_v=True,  # needed if using current NetPyNE to get spikes
                                                 gen_spike_saves_for_all_somas=True,  # will work only with the latest jNeuroML_NetPyNE (not on NSG to date: 16.08.2017)
                                                 lems_file_name="LEMS_%s.xml"%network.id,
                                                 include_extra_lems_files=["PyNN.xml"],  # to include SpikeSourcePoisson
                                                 simulation_seed=12345)
                                                 
    else:
        lems_fName = None
        
    return lems_fName
                                 

if __name__ == "__main__":

    try:
        run_simulation = sys.argv[1]
    except:
        run_simulation = False
    try:
        simulator = sys.argv[2]
    except:
        simulator = "NEURON"

    dPopsize = {"poolosyn":50, "pvbasket":20, "stim":40}
    
    dNconns = {"proj_poolosyn_to_pvbasket":30, "proj_pvbasket_to_poolosyn":18, "proj_pvbasket_to_pvbasket":18,
               "proj_ca3_to_poolosyn":50, "proj_ec_to_poolosyn":30, "proj_ca3_to_pvbasket":40}
               
    dWeightMults = {"proj_poolosyn_to_pvbasket":20, "proj_pvbasket_to_poolosyn":20, "proj_pvbasket_to_pvbasket":50,
                    "proj_ca3_to_poolosyn":50, "proj_ec_to_poolosyn":15, "proj_ca3_to_pvbasket":15}
    rate = 10
    simduration = 100  # ms
    dt = 0.01  # ms
    
    lems_fName = generate_PING_net("PINGNet", dPopsize, dNconns, dWeightMults, rate,
                                   generate_LEMS=True, duration=simduration, dt=dt)
                                   
    if lems_fName and run_simulation:
        if simulator == "NEURON":
            oc.simulate_network(lems_fName, simulator="jNeuroML_%s"%simulator,
                                max_memory="5G")
        elif simulator == "NetPyNE":
            import multiprocessing as mp
            oc.simulate_network(lems_fName, simulator="jNeuroML_%s"%simulator,
                                max_memory="5G", num_processors=mp.cpu_count())
                                
            # analyse saved results                  
            dTraces = {}; dSpikeTimes = {}; dSpikingNeurons = {}
            for cell_type in ["poolosyn", "pvbasket"]:
                t, traces = get_traces("Sim_PINGNet.pop_%s.v.dat"%cell_type, simduration, dt, dPopsize[cell_type])
                spikeTimes, spikingNeurons = get_spikes(t, traces)
                dSpikeTimes[cell_type] = spikeTimes; dSpikingNeurons[cell_type] = spikingNeurons
                dTraces[cell_type] = traces[0, :]
                
                plot_rasters(dSpikeTimes, dSpikingNeurons, simduration=t[-1], saveName="PINGNet")
                plot_traces(t, dTraces, saveName="PINGNet")
        else:
            raise Exception("simulator:%s is not yet implemented"%simulator)


